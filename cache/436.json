{"id": 436, "ids": "436", "state": "None", "name": "Find Right Interval", "key": "find-right-interval", "link": "https://leetcode.com/problems/find-right-interval", "locked": false, "percent": 41.138244749982896, "level": "Medium", "starred": false, "loaded": true, "totalAC": "", "totalSubmit": "", "desc": "\r\nGiven a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the \"right\" of i.\r\n\r\n\r\n\r\nFor any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the \"right\" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.\r\n\r\n\r\nNote:\r\n\r\nYou may assume the interval's end point is always bigger than its start point.\r\nYou may assume none of these intervals have the same start point.\r\n\r\n\r\n\r\nExample 1:\r\n\r\nInput: [ [1,2] ]\r\n\r\nOutput: [-1]\r\n\r\nExplanation: There is only one interval in the collection, so it outputs -1.\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: [ [3,4], [2,3], [1,2] ]\r\n\r\nOutput: [-1, 0, 1]\r\n\r\nExplanation: There is no satisfied \"right\" interval for [3,4].\r\nFor [2,3], the interval [3,4] has minimum-\"right\" start point;\r\nFor [1,2], the interval [2,3] has minimum-\"right\" start point.\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: [ [1,4], [2,3], [3,4] ]\r\n\r\nOutput: [-1, 2, -1]\r\n\r\nExplanation: There is no satisfied \"right\" interval for [1,4] and [3,4].\r\nFor [2,3], the interval [3,4] has minimum-\"right\" start point.\r\n\r\n", "templates": [{"value": "cpp", "text": "C++", "defaultCode": "/**\r\n * Definition for an interval.\r\n * struct Interval {\r\n *     int start;\r\n *     int end;\r\n *     Interval() : start(0), end(0) {}\r\n *     Interval(int s, int e) : start(s), end(e) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    vector<int> findRightInterval(vector<Interval>& intervals) {\r\n        \r\n    }\r\n};"}, {"value": "java", "text": "Java", "defaultCode": "/**\r\n * Definition for an interval.\r\n * public class Interval {\r\n *     int start;\r\n *     int end;\r\n *     Interval() { start = 0; end = 0; }\r\n *     Interval(int s, int e) { start = s; end = e; }\r\n * }\r\n */\r\npublic class Solution {\r\n    public int[] findRightInterval(Interval[] intervals) {\r\n        \r\n    }\r\n}"}, {"value": "python", "text": "Python", "defaultCode": "# Definition for an interval.\r\n# class Interval(object):\r\n#     def __init__(self, s=0, e=0):\r\n#         self.start = s\r\n#         self.end = e\r\n\r\nclass Solution(object):\r\n    def findRightInterval(self, intervals):\r\n        \"\"\"\r\n        :type intervals: List[Interval]\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        "}, {"value": "c", "text": "C", "defaultCode": "/**\r\n * Definition for an interval.\r\n * struct Interval {\r\n *     int start;\r\n *     int end;\r\n * };\r\n */\r\n/**\r\n * Return an array of size *returnSize.\r\n * Note: The returned array must be malloced, assume caller calls free().\r\n */\r\nint* findRightInterval(struct Interval* intervals, int intervalsSize, int* returnSize) {\r\n    \r\n}"}, {"value": "csharp", "text": "C#", "defaultCode": "/**\r\n * Definition for an interval.\r\n * public class Interval {\r\n *     public int start;\r\n *     public int end;\r\n *     public Interval() { start = 0; end = 0; }\r\n *     public Interval(int s, int e) { start = s; end = e; }\r\n * }\r\n */\r\npublic class Solution {\r\n    public int[] FindRightInterval(Interval[] intervals) {\r\n        \r\n    }\r\n}"}, {"value": "javascript", "text": "JavaScript", "defaultCode": "/**\r\n * Definition for an interval.\r\n * function Interval(start, end) {\r\n *     this.start = start;\r\n *     this.end = end;\r\n * }\r\n */\r\n/**\r\n * @param {Interval[]} intervals\r\n * @return {number[]}\r\n */\r\nvar findRightInterval = function(intervals) {\r\n    \r\n};"}, {"value": "ruby", "text": "Ruby", "defaultCode": "# Definition for an interval.\r\n# class Interval\r\n#     attr_accessor :start, :end\r\n#     def initialize(s=0, e=0)\r\n#         @start = s\r\n#         @end = e\r\n#     end\r\n# end\r\n\r\n# @param {Interval[]} intervals\r\n# @return {Integer[]}\r\ndef find_right_interval(intervals)\r\n    \r\nend"}, {"value": "swift", "text": "Swift", "defaultCode": "/**\r\n * Definition for an interval.\r\n * public class Interval {\r\n *   public var start: Int\r\n *   public var end: Int\r\n *   public init(_ start: Int, _ end: Int) {\r\n *     self.start = start\r\n *     self.end = end\r\n *   }\r\n * }\r\n */\r\nclass Solution {\r\n    func findRightInterval(_ intervals: [Interval]) -> [Int] {\r\n        \r\n    }\r\n}"}, {"value": "golang", "text": "Go", "defaultCode": "/**\r\n * Definition for an interval.\r\n * type Interval struct {\r\n *\t   Start int\r\n *\t   End   int\r\n * }\r\n */\r\nfunc findRightInterval(intervals []Interval) []int {\r\n    \r\n}"}, {"value": "scala", "text": "Scala", "defaultCode": "/**\n * Definition for an interval.\n * class Interval(var _start: Int = 0, var _end: Int = 0) {\n *   var start: Int = _start\n *   var end: Int = _end\n * }\n */\nobject Solution {\n    def findRightInterval(intervals: Array[Interval]): Array[Int] = {\n        \n    }\n}"}], "testcase": "[[1,2]]", "testable": true}