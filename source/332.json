{
 "id": 332,
 "name": "Reconstruct Itinerary",
 "key": "reconstruct-itinerary",
 "link": "https://leetcode.com/problems/reconstruct-itinerary",
 "percent": 29.02156851345852,
 "level": "Medium",
 "totalAC": "",
 "totalSubmit": "",
 "desc": "Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.\r\n\r\n\r\nNote:\r\n\r\nIf there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"].\r\nAll airports are represented by three capital letters (IATA code).\r\nYou may assume all tickets form at least one valid itinerary.\r\n\r\n\r\n\r\n\r\n    Example 1:\r\n    tickets = [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\r\n    Return [\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"].\r\n\r\n\r\n    Example 2:\r\n    tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\r\n    Return [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"].\r\n    Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"]. But it is larger in lexical order.\r\n\r\n\r\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.",
 "templates": [
  {
   "value": "cpp",
   "text": "C++",
   "defaultCode": "class Solution {\r\npublic:\r\n    vector<string> findItinerary(vector<pair<string, string>> tickets) {\r\n        \r\n    }\r\n};"
  },
  {
   "value": "java",
   "text": "Java",
   "defaultCode": "public class Solution {\r\n    public List<String> findItinerary(String[][] tickets) {\r\n        \r\n    }\r\n}"
  },
  {
   "value": "python",
   "text": "Python",
   "defaultCode": "class Solution(object):\r\n    def findItinerary(self, tickets):\r\n        \"\"\"\r\n        :type tickets: List[List[str]]\r\n        :rtype: List[str]\r\n        \"\"\"\r\n        "
  },
  {
   "value": "c",
   "text": "C",
   "defaultCode": "/**\r\n * Return an array of size *returnSize.\r\n * Note: The returned array must be malloced, assume caller calls free().\r\n */\r\nchar** findItinerary(char*** tickets, int ticketsRowSize, int ticketsColSize, int* returnSize) {\r\n    \r\n}"
  },
  {
   "value": "csharp",
   "text": "C#",
   "defaultCode": "public class Solution {\r\n    public IList<string> FindItinerary(string[,] tickets) {\r\n        \r\n    }\r\n}"
  },
  {
   "value": "javascript",
   "text": "JavaScript",
   "defaultCode": "/**\r\n * @param {string[][]} tickets\r\n * @return {string[]}\r\n */\r\nvar findItinerary = function(tickets) {\r\n    \r\n};"
  },
  {
   "value": "ruby",
   "text": "Ruby",
   "defaultCode": "# @param {string[][]} tickets\r\n# @return {String[]}\r\ndef find_itinerary(tickets)\r\n    \r\nend"
  },
  {
   "value": "swift",
   "text": "Swift",
   "defaultCode": "class Solution {\r\n    func findItinerary(_ tickets: [[String]]) -> [String] {\r\n        \r\n    }\r\n}"
  },
  {
   "value": "golang",
   "text": "Go",
   "defaultCode": "func findItinerary(tickets [][]string) []string {\n    \n}"
  },
  {
   "value": "scala",
   "text": "Scala",
   "defaultCode": "object Solution {\n    def findItinerary(tickets: Array[Array[String]]): List[String] = {\n        \n    }\n}"
  }
 ],
 "testcase": "[[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]",
 "testable": true
}